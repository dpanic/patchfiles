output: /usr/bin/autotune.sh
categories: 
  - networking
  - performance
mode: overwrite
commentCharacter: "#"
commandsAfter: 
  - chmod +x /usr/bin/autotune.sh
  - |
    # Create systemd service to run autotune.sh after sysctl.conf is loaded
    # This ensures autotune.sh runs AFTER systemd-sysctl.service, so dynamic values override static ones
    SERVICE_FILE="/etc/systemd/system/autotune.service"
    SERVICE_DIR="/etc/systemd/system"
    
    # Create service file
    cat > "$SERVICE_FILE" << 'EOFSERVICE'
    [Unit]
    Description=Dynamic kernel parameter tuning based on RAM
    After=systemd-sysctl.service network-online.target
    Requires=systemd-sysctl.service
    Wants=network-online.target
    # Ensure this runs after all sysctl operations are complete
    After=sysctl.service
    
    [Service]
    Type=oneshot
    # Explicitly run as root (default, but making it clear for sysctl -w)
    User=root
    Group=root
    ExecStart=/usr/bin/autotune.sh
    RemainAfterExit=yes
    StandardOutput=journal
    StandardError=journal

    
    [Install]
    WantedBy=multi-user.target
    EOFSERVICE
    
    # Reload systemd and enable service
    systemctl daemon-reload
    systemctl enable autotune.service
description:
  configure conntrack_max, tcp_max_tw_buckets, and fs.file-max dynamically based on available RAM. creates script in /usr/bin/autotune.sh and creates systemd service that runs after sysctl.conf is loaded to ensure dynamic values override static ones.
body: |
  #!/usr/bin/env bash

  set -euo pipefail

  # PATCHFILES START - autotune configuration
  # Ensure we're running as root (required for sysctl -w)
  if [ "$EUID" -ne 0 ]; then
      echo "Error: This script must be run as root" >&2
      exit 1
  fi
  # Minimum number of conntrack entries
  MIN_CONNTRACK=65536

  # Number of entries per 1 GB RAM (e.g., 65536 => 8 GB â‰ˆ 524288)
  PER_GB=65536

  # Extract total RAM in kB (MemTotal = total installed RAM, not free RAM)
  MEM_KB=$(awk '/MemTotal/ {print $2}' /proc/meminfo)
  
  # Debug: Show what we're reading
  echo "Debug: MemTotal from /proc/meminfo = ${MEM_KB} kB"

  # Convert to GB and round up to nearest whole number (e.g., 3.8GB -> 4GB)
  # Using ceil logic: if there's any decimal part, round up
  RAM_GB=$(awk "BEGIN {ram_gb = $MEM_KB / 1024 / 1024; print (ram_gb == int(ram_gb)) ? int(ram_gb) : int(ram_gb) + 1}")
  [ "$RAM_GB" -lt 1 ] && RAM_GB=1
  
  echo "Debug: Calculated RAM_GB = ${RAM_GB} GB (rounded up from $(awk "BEGIN {printf \"%.2f\", $MEM_KB / 1024 / 1024}") GB)"

  # Calculate desired limit
  TARGET_MAX=$((RAM_GB * PER_GB))

  # Apply minimum limit
  if [ "$TARGET_MAX" -lt "$MIN_CONNTRACK" ]; then
      TARGET_MAX=$MIN_CONNTRACK
  fi

  # ============================================================================
  # SECTION: Set conntrack_max
  # ============================================================================
  SYSCTL_KEY="net.netfilter.nf_conntrack_max"
  
  # Load nf_conntrack module if not already loaded
  if ! lsmod | grep -q "^nf_conntrack "; then
      echo "Loading nf_conntrack module..."
      if modprobe nf_conntrack 2>/dev/null; then
          # Wait a moment for module to fully initialize and create sysctl parameters
          sleep 1
          echo "nf_conntrack module loaded successfully"
      else
          echo "Warning: Could not load nf_conntrack module. Skipping conntrack_max setting."
          SYSCTL_KEY=""
      fi
  fi
  
  # Only set conntrack_max if parameter exists (module is loaded)
  if [ -n "$SYSCTL_KEY" ] && [ -f "/proc/sys/net/netfilter/nf_conntrack_max" ]; then
      CURRENT=$(sysctl -n "$SYSCTL_KEY" 2>/dev/null || echo 0)
      if [ "$CURRENT" -ne "$TARGET_MAX" ]; then
          echo "Setting $SYSCTL_KEY=$TARGET_MAX (RAM=${RAM_GB}G, was=$CURRENT)"
          sysctl -w "$SYSCTL_KEY=$TARGET_MAX" >/dev/null
      else
          echo "$SYSCTL_KEY already $CURRENT, nothing to do."
      fi
  elif [ -n "$SYSCTL_KEY" ]; then
      echo "Warning: nf_conntrack_max parameter not available even after loading module. Module may not be supported on this system."
  fi

  # ============================================================================
  # SECTION: Set tcp_max_tw_buckets
  # ============================================================================
  # Should match or be close to conntrack_max
  TCP_MAX_TW_KEY="net.ipv4.tcp_max_tw_buckets"
  TCP_MAX_TW_CURRENT=$(sysctl -n "$TCP_MAX_TW_KEY" 2>/dev/null || echo 0)
  if [ "$TCP_MAX_TW_CURRENT" -ne "$TARGET_MAX" ]; then
      echo "Setting $TCP_MAX_TW_KEY=$TARGET_MAX (RAM=${RAM_GB}G, was=$TCP_MAX_TW_CURRENT)"
      sysctl -w "$TCP_MAX_TW_KEY=$TARGET_MAX" >/dev/null
  else
      echo "$TCP_MAX_TW_KEY already $TCP_MAX_TW_CURRENT, nothing to do."
  fi

  # ============================================================================
  # SECTION: Set fs.file-max
  # ============================================================================
  # Formula: RAM_GB * 262144 (e.g., 8 GB = 2097152)
  FILE_MAX_PER_GB=262144
  FILE_MAX_TARGET=$((RAM_GB * FILE_MAX_PER_GB))
  FILE_MAX_MIN=1048576
  if [ "$FILE_MAX_TARGET" -lt "$FILE_MAX_MIN" ]; then
      FILE_MAX_TARGET=$FILE_MAX_MIN
  fi

  FILE_MAX_KEY="fs.file-max"
  FILE_MAX_CURRENT=$(sysctl -n "$FILE_MAX_KEY" 2>/dev/null || echo 0)
  if [ "$FILE_MAX_CURRENT" -ne "$FILE_MAX_TARGET" ]; then
      echo "Setting $FILE_MAX_KEY=$FILE_MAX_TARGET (RAM=${RAM_GB}G, was=$FILE_MAX_CURRENT)"
      sysctl -w "$FILE_MAX_KEY=$FILE_MAX_TARGET" >/dev/null
  else
      echo "$FILE_MAX_KEY already $FILE_MAX_CURRENT, nothing to do."
  fi
  # PATCHFILES END - autotune configuration

